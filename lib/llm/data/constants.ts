export const trilogyRules = [
  'Trilogy replaces the GROUP BY clause with implicit grouping based on the non-aggregated fields in the SELECT list. For aggregations requiring different dimensions within the same query, use the by specifier inside the aggregate function: agg_func(metric) by dim1, dim2.',
  'Trilogy does not use the FROM clause. All fields are resolved from a global namespace. No answer should contain the FROM sql keyword.',
  'Trilogy does not have a standalone DISTINCT keyword. count_distinct can be used as a function to get the unique count of an object, but in most cases, when getting a count of an item, just do a count of the field as trilogy will resolve to the unique grain.',
  'Trilogy does not have the UNION keyword. To combine fields, use a coalesce for dimensions and just add (or whatever appropriate) for metrics.',
  'Trilogy uses the where clause to filter before a query, and the having clause to filter the output of a query. Notably, an aggregate that is output in the query can only be filtered in the having; other aggregates can be filtered in the where',
  'Some datatypes will have traits - traits are hints on semantic meaning and the value of a field, such as "this decimal is a percent" or "this string is a zipcode"',
  'Trilogy uses # for comments. For multiline comments, comment each line. A comment must have a newline after it. DO NOT use -- or /* */ for comments.',
  'If you use a where clause, place it before the select.',
  'Trilogy fields will look like struct paths - order.product.id. Use the full path.',
  'use date_add to manipulate dates, like date_add(ship_date, month, 3)',
  'Avoid naming fields after SQL keywords. For example, do not name a field "order" or "select".',
  'Ordering must always explicitly specify direction for each member - asc or desc. There is no default.',
  'If you filter on an aggregate in the select, add a HAVING clause for that portion of logic. Aggregates can be used in a where clause if they are not also selected.',
  'When comparing a field against a string in your query, explicitly cast the string to ensure the comparison is safe if the field is not also a string. Use the :: operator to cast, like "2021-01-01"::date',
  'Do not rename fields with as unless you are transforming them. For example, if you are doing a calculation, you can rename the field with as. If you are just selecting the field, do not use as. Any select field that is a transformation must be aliased with as, however.',
  'You can derive a new field from an existing field using sql functions in any position. If you need - and only if you need - an aggregate to have a different grouping than the select, you can do an inline group - ex sum(revenue) by order.year, order.customer.state as revenue_per_year_and_state. You can use this to get aggregates at different levels than the default select aggregation in the same query. ',
  'Window syntax is not like SQL. If you are trying to get the top X based on ordering by A and B (optionally within a group Z), use the syntax "rank X over Z by A desc, B desc" - ex "rank customer over state by sum(revenue) desc as top_per_state_customers". This applies to other similar window functions as well.',
  'Trilogy does not have the * symbol for counting. The count function requires a field as an argument. ID fields are good options for counts.',
  'Trilogy will let you immediately reuse a field by name after defining it in the select; if you can reuse a calculation you just defined, do that rather than repeating it.',
  'Only reference fields from the select in the HAVING clause. You can create new fields and hide them with a # comment to reference them for filtering. A # commented field will not be selected but will be available to filter. The where clause is less restrictive, and can include anonymous calculations.',
  'To get a max or minimum in where/having clauses, there is no need for a subselect - just do max(field) or min(field), such as in "where field_a=max(field_b);"',
  'End a full statement with a semicolon.',
]

export const functions = [
  'abs',
  'alias',
  // 'attr_access',
  'avg',
  'bool',
  'cast',
  'coalesce',
  'concat',
  'contains',
  'count',
  'count_distinct',
  'current_date',
  'current_datetime',
  'date',
  'date_add',
  'date_diff',
  'date_part',
  'date_sub',
  'date_truncate',
  'datetime',
  'day',
  'day_of_week',
  // 'group',
  'hour',
  // 'index_access',
  'isnull',
  'len',
  'length',
  'like',
  'lower',
  // 'map_access',
  'max',
  'min',
  'minute',
  'month',
  'now',
  'quarter',
  'random',
  'round',
  'second',
  'split',
  'sqrt',
  'strpos',
  'struct',
  'substring',
  'sum',
  'timestamp',
  'trim',
  'unix_to_timestamp',
  'unnest',
  'upper',
  'week',
  'year',
]
export const datatypes = [
  // PRIMITIVES
  'string',
  'bool',
  'map',
  'list',
  'number',
  'float',
  'numeric',
  'int',
  'date',
  'datetime',
  'timestamp',
  'array',
  'struct',
  'null',
  // GRANULAR
  'unix_seconds',
  // PARSING
  'unknown',
]

export const rulesInput = 'Rule: ' + trilogyRules.join('\nRule: ')
