export const trilogyRules = [
  'Trilogy does not use GROUP BY clauses. Do not include a GROUP BY even if you aggregate. No answer should contain the GROUP BY sql keywords.',
  'Trilogy does not use the FROM clause. All fields are resolved from a global namespace. No answer should contain the FROM sql keyword.',
  'Trilogy does not have the DISTINCT keyword. Do not use it. When getting a count of an item, just do a count of the field.',
  'Trilogy does not have the UNION keyword. To combine fields, use a coalesce for dimensions and just add (or whatever appropriate) for metrics.',
  'Trilogy uses # for comments. For multiline comments, comment each line. A comment must have a newline after it. DO NOT use -- or /* */ for comments.',
  'If you use a where clause, place it before the select.',
  'Trilogy fields will look like struct paths - order.product.id. Use the full path.',
  'use date_add to manipulate dates, like date_add(ship_date, month, 3)',
  'Avoid naming fields after SQL keywords. For example, do not name a field "order" or "select".',
  'Ordering must always explicitly specify direction for each member - asc or desc. There is no default.',
  'If you filter on an aggregate in the select, add a HAVING clause for that portion of logic. Aggregates can be used in a where clause if they are not also selected.',
  'When comparing a field against a string in your query, explicitly cast the string to ensure the comparison is safe if the field is not also a string. Use the :: operator to cast, like "2021-01-01"::date',
  'Do not rename fields with as unless you are transforming them. For example, if you are doing a calculation, you can rename the field with as. If you are just selecting the field, do not use as.',
  'You can derive a new field from an existing field using sql functions in any position. ALWAYS alias a calculation using the by keyword. If you need - and only if you need - an aggregate to have a different grouping than the select, you can do an inline group - ex sum(revenue) by order.year, order.customer.state as revenue_per_year_and_state. You can use this to get aggregates at different levels than the default select aggregation in the same query. ',
  'Window syntax is not like SQL. If you are trying to get the top X based on ordering by A and B (optionally within a group Z), use the syntax "rank X over Z by A desc, B desc" - ex "rank customer over state by sum(revenue) desc as top_per_state_customers". This applies to other similar window functions as well.',
  'Trilogy does not have the * symbol for counting. The count function requires a field as an argument. ID fields are good options for counts.',
  'Trilogy will let you immediately reuse a field by name after defining it in the select; if you can reuse a calculation you just defined, do that rather than repeating it.',
  'Only reference fields from the select in the HAVING clause. You can create new fields and hide them with a -- comment to reference them for filtering. The where clause is less restrictive, and can include anonymous calculations.',
  'To get a max or minimum in where/having clauses, there is no need for a subselect - just do max(field) or min(field), such as in "where field_a=max(field_b);"',
  'End a full statement with a semicolon.',
]

export const functions = [
  'abs',
  'alias',
  // 'attr_access',
  'avg',
  'bool',
  'cast',
  'coalesce',
  'concat',
  'contains',
  'count',
  'count_distinct',
  'current_date',
  'current_datetime',
  'date',
  'date_add',
  'date_diff',
  'date_part',
  'date_sub',
  'date_truncate',
  'datetime',
  'day',
  'day_of_week',
  // 'group',
  'hour',
  // 'index_access',
  'isnull',
  'len',
  'length',
  'like',
  'lower',
  // 'map_access',
  'max',
  'min',
  'minute',
  'month',
  'now',
  'quarter',
  'random',
  'round',
  'second',
  'split',
  'sqrt',
  'strpos',
  'struct',
  'substring',
  'sum',
  'sum',
  'timestamp',
  'trim',
  'unix_to_timestamp',
  'unnest',
  'upper',
  'week',
  'year',
]
export const datatypes = [
  // PRIMITIVES
  'string',
  'bool',
  'map',
  'list',
  'number',
  'float',
  'numeric',
  'int',
  'bigint',
  'date',
  'datetime',
  'timestamp',
  'array',
  'date_part',
  'struct',
  'null',
  // GRANULAR
  'unix_seconds',
  // PARSING
  'unknown',
]

export const rulesInput = 'Rule: ' + trilogyRules.join('\nRule: ')
